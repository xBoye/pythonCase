求可达性矩阵步骤：
首先求出邻接矩阵A，设A的阶为n，即n×n方阵。
接着求矩阵幂，2次方求到n次方，A的n次方用An来表示。求矩阵幂用矩阵的布尔乘积来做，如A2 = A×A，布尔乘积矩阵对应行列相乘相加，相乘的时候用逻辑与，相加的时候用逻辑或，保证结果元素还是0,1。
最后求可达性矩阵P等于A、A2...，一直到An求逻辑或运算，即：
P = A ∨ A2∨ ...∨ An

【例】已知邻接矩阵A，求可达性矩阵P。
> 邻接矩阵A
[0, 1, 1, 0]
[0, 0, 0, 0]
[0, 1, 0, 1]
[1, 1, 0, 0]
> A2 = A**2 = A × A   # 2次方
matrix([[0, 1, 0, 1],
        [0, 0, 0, 0],
        [1, 1, 0, 0],
        [0, 1, 1, 0]])
> A3 = A**3 = A2 × A
matrix([[1, 1, 0, 0],
        [0, 0, 0, 0],
        [0, 1, 1, 0],
        [0, 1, 0, 1]])
> A4 = A**4
matrix([[0, 1, 1, 0],
        [0, 0, 0, 0],
        [0, 1, 0, 1],
        [1, 1, 0, 0]])

【注】4阶矩阵最多求到4次幂。

> 可达性矩阵P = A ∨ A2 ∨ A3 ∨ A4
matrix([[1, 1, 1, 1],
        [0, 0, 0, 0],
        [1, 1, 1, 1],
        [1, 1, 1, 1]])
		
【复习题】已知邻接矩阵求可达性矩阵P及强分图。。
求可达性矩阵步骤：
首先求出邻接矩阵A，设A的阶为n，即n×n方阵。
接着求矩阵幂，2次方求到n次方，A的n次方用An来表示。求矩阵幂用矩阵的布尔乘积来做，如A2 = A×A，布尔乘积矩阵对应行列相乘相加，相乘的时候用逻辑与，相加的时候用逻辑或，保证结果元素还是0,1。
最后求可达性矩阵P等于A、A2...，一直到An求逻辑或运算，即：
P = A ∨ A2∨ ...∨ An

以下由程序自动生成邻接矩阵并按步骤求出强分图~
# -*- coding: utf-8 -*-
"""
Created on Tue Sep 11 21:20:08 2018
@title：邻接矩阵求可达性矩阵，并求强分图
@author: ff7f
"""
from 矩阵类 import *
#q = "已知邻接矩阵\n{A}，求可达性矩阵P，并找出所有强分图。"
n = input('> 随机生成邻接矩阵，请输入矩阵阶数：')
while n:
    A = genMatrix(int(n))   # 随机生成邻接矩阵A
    print(f"【例】已知邻接矩阵A：\n{A}\n求可达性矩阵P，并找出所有强分图。")
    funcs = [strongSubGraph]   # 计算强分图函数
    flowCalc(A, *funcs)
    #pageRank(A)   #pageRank算法求结点权重
    n = input('> 请输入矩阵阶数：')

==== 输出结果 ====
> 随机生成邻接矩阵，请输入矩阵阶数：4
【例】已知邻接矩阵A：
[[0 1 0 1]
 [1 0 0 0]
 [0 1 0 0]
 [0 1 0 0]]
求可达性矩阵P，并找出所有强分图。
> A2 = A**2
matrix([[1, 1, 0, 0],
        [0, 1, 0, 1],
        [1, 0, 0, 0],
        [1, 0, 0, 0]])
> A3 = A**3
matrix([[1, 1, 0, 1],
        [1, 1, 0, 0],
        [0, 1, 0, 1],
        [0, 1, 0, 1]])
> A4 = A**4   #4阶矩阵最多求到4次幂。
matrix([[1, 1, 0, 1],
        [1, 1, 0, 1],
        [1, 1, 0, 0],
        [1, 1, 0, 0]])
> 可达性矩阵P = A ∨ A2 ∨ ... ∨ An
matrix([[1, 1, 0, 1],
        [1, 1, 0, 1],
        [1, 1, 0, 1],
        [1, 1, 0, 1]])
> 可达性矩阵转置矩阵P.T
matrix([[1, 1, 1, 1],
        [1, 1, 1, 1],
        [0, 0, 0, 0],
        [1, 1, 1, 1]])
> 相互可达矩阵(P^P.T)
[1, 1, 0, 1]
[1, 1, 0, 1]
[0, 0, 0, 0]
[1, 1, 0, 1]
> 所有强分图(相互可达矩阵中找出所有双向可达的最大结点子集就是强分图)
{'v2', 'v4', 'v1'}，{'v3'}